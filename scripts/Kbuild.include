####
# kbuild: Generic definitions

        #定义一些有用的变量和命令等

# Convenient variables
comma   := ,
quote   := "
squote  := '
empty   :=
space   := $(empty) $(empty)

        # dir取目录，notdir取最后的文件名称
        # 效果就是在文件名称前加个.变成隐藏文件

###
# Name of target with a '.' as filename prefix. foo/bar.o => foo/.bar.o
dot-target = $(dir $@).$(notdir $@)

        # 把依赖文件名称中的逗号替换为下划线

###
# The temporary file to save gcc -MD generated dependencies must not
# contain a comma
depfile = $(subst $(comma),_,$(dot-target).d)

        # 去掉目录和扩展名
        # basename 取前缀
        # notdir 取文件名
        # $@ 所有目标

###
# filename of target with directory and extension stripped
basetarget = $(basename $(notdir $@))

        # $< 第一个依赖

###
# filename of first prerequisite with directory and extension stripped
baseprereq = $(basename $(notdir $<))

        # 对echo中的单引号进行转义

###
# Escape single quote for use in echo statements
escsq = $(subst $(squote),'\$(squote)',$1)

###
# Easy method for doing a status message
       kecho := :
 quiet_kecho := echo
silent_kecho := :
kecho := $($(quiet)kecho)

###
# filechk is used to check if the content of a generated file is updated.
# Sample usage:
# define filechk_sample
#	echo $KERNELRELEASE
# endef
# version.h : Makefile
#	$(call filechk,sample)
# The rule defined shall write to stdout the content of the new file.
# The existing file will be compared with the new one.
# - If no file exist it is created
# - If the content differ the new file is used
# - If they are equal no change, and no timestamp update
# - stdin is piped in from the first prerequisite ($<) so one has
#   to specify a valid file as first prerequisite (often the kbuild file)

        # set -e 之后的代码，一旦出现返回值非0，则立即退出
        # 打印'  CHK     目标文件'提示信息
        # 创建目录
        # 
        # -r 文件存在且可读，为真
        # cmp 按字节比较两个文件 -s 安静模式，不输出信息
        #
        # 例如:
        # filechk_version.h
        #   include/generated/uapi/linux/version.h.tmp
        # filechk_utsrelease.h
        #   include/generated/utsrelease.h.tmp

define filechk
	$(Q)set -e;				\
	$(kecho) '  CHK     $@';		\
	mkdir -p $(dir $@);			\
	$(filechk_$(1)) < $< > $@.tmp;		\
	if [ -r $@ ] && cmp -s $@ $@.tmp; then	\
		rm -f $@.tmp;			\
	else					\
		$(kecho) '  UPD     $@';	\
		mv -f $@.tmp $@;		\
	fi
endef

######
# gcc support functions
# See documentation in Documentation/kbuild/makefiles.txt

# cc-cross-prefix
# Usage: CROSS_COMPILE := $(call cc-cross-prefix, m68k-linux-gnu- m68k-linux-)
# Return first prefix where a prefix$(CC) is found in PATH.
# If no $(CC) found in PATH with listed prefixes return nothing

        # 查找存在的prefix$(CC)交叉编译程序
        # 返回存在的那个交叉编译程序的前缀
        #
        # $(word <n>,<text>) 取字符串第一个单词，从1开始
        #
        # $(foreach <var>,<list>,<text>) 
        #   把参数<list>中的单词逐一取出放到参数<var>指定的变量中，
        #   然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，
        #   <text>所返回的每个字符串会以空格分隔，最后循环结束时，
        #   <text>所返回的每个字符串组成的整个字符串(以空格分隔)将会是foreac函数的返回值。
        #
        # $(strip <string>) 去空格函数，去掉<string>字串中开头和结尾的空字符。
        #
        # which 返回程序的完成路径

cc-cross-prefix =  \
	$(word 1, $(foreach c,$(1),                                   \
		$(shell set -e;                                       \
		if (which $(strip $(c))$(CC)) > /dev/null 2>&1 ; then \
			echo $(c);                                    \
		fi)))

        # $(if <condition>,<then-part>)或$(if <condition>,<then-part>,<else-part>)
        # 而if函数的返回值是，如果<condition>为真（非空字符串），
        # 那个<then-part>会是整 个函数的返回值，
        # 如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，
        # 此时如果<else-part>没有被定义，那么，整个函数返回空字串。 
        # 所以，<then-part>和<else-part>只会有一个被计算。 
        #
        # $(firstword <text>) 取字符串<text>中的第一个单词。

# output directory for tests below
TMPOUT := $(if $(KBUILD_EXTMOD),$(firstword $(KBUILD_EXTMOD))/)

# try-run
# Usage: option = $(call try-run, $(CC)...-o "$$TMP",option-ok,otherwise)
# Exit code chooses option. "$$TMP" is can be used as temporary file and
# is automatically cleaned up.

        # 尝试执行call try-run的第一个参数命令
        # 根据$(1)的执行结果，返回$(2)或$(3)

try-run = $(shell set -e;		\
	TMP="$(TMPOUT).$$$$.tmp";	\
	TMPO="$(TMPOUT).$$$$.o";	\
	if ($(1)) >/dev/null 2>&1;	\
	then echo "$(2)";		\
	else echo "$(3)";		\
	fi;				\
	rm -f "$$TMP" "$$TMPO")

# as-option
# Usage: cflags-y += $(call as-option,-Wa$(comma)-isa=foo,)

        # $(call <expression>,<parm1>,<pram2>,<parm3>...)
        # 当make执行整个函数时，<expression>参数中的变量，
        # 如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。
        # 而<expression>的返回值就是call函数的返回值。
        #
        # gcc 选项 -c 编译或汇编源文件，但是不链接
        # gcc 选项 -x language 明确指明随后输入文件使用的语言
        # 例如: c c++ assembler
        #
        # 使用选项$(1)进行汇编，选项ok的话返回该选项$(1)，否则返回$(2)

as-option = $(call try-run,\
	$(CC) $(KBUILD_CFLAGS) $(1) -c -x assembler /dev/null -o "$$TMP",$(1),$(2))

# as-instr
# Usage: cflags-y += $(call as-instr,instr,option1,option2)

        # as-instr检测汇编器是否报告一个特殊指令并输出选项1或选项2。

as-instr = $(call try-run,\
	printf "%b\n" "$(1)" | $(CC) $(KBUILD_AFLAGS) -c -x assembler -o "$$TMP" -,$(2),$(3))

# cc-option
# Usage: cflags-y += $(call cc-option,-march=winchip-c6,-march=i586)

        # cc-option用来检测$(CC)是否支持一个给定式的选项。支持则返回该选项$(1)。

cc-option = $(call try-run,\
	$(CC) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) $(1) -c -x c /dev/null -o "$$TMP",$(1),$(2))

# cc-option-yn
# Usage: flag := $(call cc-option-yn,-march=winchip-c6)

        # 返回y或n

cc-option-yn = $(call try-run,\
	$(CC) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) $(1) -c -x c /dev/null -o "$$TMP",y,n)

# cc-option-align
# Prefix align with either -falign or -malign

        # $(subst <from>,<to>,<text>) 字符串替换函数
        # 把字串<text>中的<from>字符串替换成<to>。
        # 返回-falign或-malign

cc-option-align = $(subst -functions=0,,\
	$(call cc-option,-falign-functions=0,-malign-functions=0))

# cc-disable-warning
# Usage: cflags-y += $(call cc-disable-warning,unused-but-set-variable)

        # 使用-W检查警告选项是否支持
        # 支持的话则返回-Wno-去掉该警告选项
        # $$TMP为try-run中定义的变量

cc-disable-warning = $(call try-run,\
	$(CC) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) -W$(strip $(1)) -c -x c /dev/null -o "$$TMP",-Wno-$(strip $(1)))

# cc-version
# Usage gcc-ver := $(call cc-version)

        # gcc版本号，如:0407

cc-version = $(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-version.sh $(CC))

# cc-fullversion
# Usage gcc-ver := $(call cc-fullversion)

        # 完整的gcc版本号，带补丁等级，如:040702

cc-fullversion = $(shell $(CONFIG_SHELL) \
	$(srctree)/scripts/gcc-version.sh -p $(CC))

# cc-ifversion
# Usage:  EXTRA_CFLAGS += $(call cc-ifversion, -lt, 0402, -O1)

        # 如果gcc版本号满足判断条件，则输出$(3)
        # 例如:$(call cc-ifversion, -lt, 0402, -O1)
        # 如果gcc版本号小于0402，则输出-O1

cc-ifversion = $(shell [ $(call cc-version, $(CC)) $(1) $(2) ] && echo $(3))

# cc-ldoption
# Usage: ldflags += $(call cc-ldoption, -Wl$(comma)--hash-style=both)

        # 判断是否支持该ld链接选项
        # 支持则返回该选项
        # $$TMP为try-run中定义的变量

cc-ldoption = $(call try-run,\
	$(CC) $(1) -nostdlib -x c /dev/null -o "$$TMP",$(1),$(2))

# ld-option
# Usage: LDFLAGS += $(call ld-option, -X)

        # 判断是否支持该ld链接选项
        # 支持则返回该选项
        # $$TMP，$$TMP0为try-run中定义的变量

ld-option = $(call try-run,\
	$(CC) -x c /dev/null -c -o "$$TMPO" ; $(LD) $(1) "$$TMPO" -o "$$TMP",$(1),$(2))

# ar-option
# Usage: KBUILD_ARFLAGS := $(call ar-option,D)
# Important: no spaces around options

        # 判断$(AR)程序是否支持选项
        # 支持则返回该$(1)选项

ar-option = $(call try-run, $(AR) rc$(1) "$$TMP",$(1),$(2))

# ld-version
# Usage: $(call ld-version)
# Note this is mainly for HJ Lu's 3 number binutil versions
ld-version = $(shell $(LD) --version | $(srctree)/scripts/ld-version.sh)

# ld-ifversion
# Usage:  $(call ld-ifversion, -ge, 22252, y)
ld-ifversion = $(shell [ $(call ld-version) $(1) $(2) ] && echo $(3))

######

###
# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj=
# Usage:
# $(Q)$(MAKE) $(build)=dir

        # $(Q)$(MAKE) -f scripts/Makefile.build obj=
        # 的简写
        # 即使用scripts/Makefile.build作为Makefile
        # 使用obj指定目录
        # 如果KBUILD_SRC不为空，则使用外部的那个srctree目录

build := -f $(srctree)/scripts/Makefile.build obj

###
# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.modbuiltin obj=
# Usage:
# $(Q)$(MAKE) $(modbuiltin)=dir

        # 模块编译的简写

modbuiltin := -f $(srctree)/scripts/Makefile.modbuiltin obj

###
# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.dtbinst obj=
# Usage:
# $(Q)$(MAKE) $(dtbinst)=dir
dtbinst := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.dtbinst obj

# Prefix -I with $(srctree) if it is not an absolute path.
# skip if -I has no parameter

        # $(patsubst <pattern>,<replacement>,<text>) 模式字符串替换函数
        # 查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，
        # 如果匹配的话，则以<replacement>替换。
        # 这里，<pattern>可以包括通配符“%”，表示任意长度的字串。
        # 如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。
        # （可以用“\”来转义，以“\%”来表示真实含义的“%”字符）。
        # 函数返回被替换过后的字符串。
        #
        # $(filter-out <pattern...>,<text>) 反过滤函数
        # 以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可以有多个模式。
        # 返回不符合模式<pattern>的字串。
        #
        # 如果-I后有参数的话，且路径不是绝对路径的话
        # 则增加-I后参数的路径修改为$(srctree)绝对路径

addtree = $(if $(patsubst -I%,%,$(1)), \
$(if $(filter-out -I/%,$(1)),$(patsubst -I%,-I$(srctree)/%,$(1))) $(1))

# Find all -I options and call addtree

        # 为$($(1))中的每一项执行表达式
        # 如果含有-I选项的话，则调用addtree

flags = $(foreach o,$($(1)),$(if $(filter -I%,$(o)),$(call addtree,$(o)),$(o)))

# echo command.
# Short version is used, if $(quiet) equals `quiet_', otherwise full one.

        # 例如:$(call echo-cmd,checksrc)
        # 如果有quiet_cmd_checksrc，则打印短的信息CHECK   $<

echo-cmd = $(if $($(quiet)cmd_$(1)),\
	echo '  $(call escsq,$($(quiet)cmd_$(1)))$(echo-why)';)

	# 定义函数cmd，用来拼接成新的字符串
	# 例如: $(call cmd,vmlinux__)即得到的值为cmd_vmlinux__

# printing commands
cmd = @$(echo-cmd) $(cmd_$(1))

# Add $(obj)/ for paths that are not absolute

        # 如果$(1)中有的不是绝对路径的话
        # 则在前面加上$(obj)/改为绝对路径

objectify = $(foreach o,$(1),$(if $(filter /%,$(o)),$(o),$(obj)/$(o)))

###
# if_changed      - execute command if any prerequisite is newer than
#                   target, or command line has changed
# if_changed_dep  - as if_changed, but uses fixdep to reveal dependencies
#                   including used config symbols
# if_changed_rule - as if_changed but execute rule instead
# See Documentation/kbuild/makefiles.txt for more info

ifneq ($(KBUILD_NOCMDDEP),1)
# Check if both arguments has same arguments. Result is empty string if equal.
# User may override this check using make KBUILD_NOCMDDEP=1
arg-check = $(strip $(filter-out $(cmd_$(1)), $(cmd_$@)) \
                    $(filter-out $(cmd_$@),   $(cmd_$(1))) )
else
arg-check = $(if $(strip $(cmd_$@)),,1)
endif

# Replace >$< with >$$< to preserve $ when reloading the .cmd file
# (needed for make)
# Replace >#< with >\#< to avoid starting a comment in the .cmd file
# (needed for make)
# Replace >'< with >'\''< to be able to enclose the whole string in '...'
# (needed for the shell)
make-cmd = $(call escsq,$(subst \#,\\\#,$(subst $$,$$$$,$(cmd_$(1)))))

# Find any prerequisites that is newer than target or that does not exist.
# PHONY targets skipped in both cases.

        # $? 代表依赖文件列表中被改变过的所有文件。
        # $^ 代表所有通过目录搜索得到的依赖文件的完整路径名(目录 + 一般文件名)列表。
        #
        # 在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。
        # 这种情况下如果需要通配符有效，就需要使用函数“wildcard”，
        # 它的用法是：$(wildcard PATTERN...) 。
        # 在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。

any-prereq = $(filter-out $(PHONY),$?) $(filter-out $(PHONY) $(wildcard $^),$^)

# Execute command if command has changed or prerequisite(s) are updated.
#
if_changed = $(if $(strip $(any-prereq) $(arg-check)),                       \
	@set -e;                                                             \
	$(echo-cmd) $(cmd_$(1));                                             \
	printf '%s\n' 'cmd_$@ := $(make-cmd)' > $(dot-target).cmd)

# Execute the command and also postprocess generated .d dependencies file.
if_changed_dep = $(if $(strip $(any-prereq) $(arg-check) ),                  \
	@set -e;                                                             \
	$(echo-cmd) $(cmd_$(1));                                             \
	scripts/basic/fixdep $(depfile) $@ '$(make-cmd)' > $(dot-target).tmp;\
	rm -f $(depfile);                                                    \
	mv -f $(dot-target).tmp $(dot-target).cmd)

# Usage: $(call if_changed_rule,foo)
# Will check if $(cmd_foo) or any of the prerequisites changed,
# and if so will execute $(rule_foo).
if_changed_rule = $(if $(strip $(any-prereq) $(arg-check) ),                 \
	@set -e;                                                             \
	$(rule_$(1)))

###
# why - tell why a a target got build
#       enabled by make V=2
#       Output (listed in the order they are checked):
#          (1) - due to target is PHONY
#          (2) - due to target missing
#          (3) - due to: file1.h file2.h
#          (4) - due to command line change
#          (5) - due to missing .cmd file
#          (6) - due to target not in $(targets)
# (1) PHONY targets are always build
# (2) No target, so we better build it
# (3) Prerequisite is newer than target
# (4) The command line stored in the file named dir/.target.cmd
#     differed from actual command line. This happens when compiler
#     options changes
# (5) No dir/.target.cmd file (used to store command line)
# (6) No dir/.target.cmd file and target not listed in $(targets)
#     This is a good hint that there is a bug in the kbuild file
ifeq ($(KBUILD_VERBOSE),2)
why =                                                                        \
    $(if $(filter $@, $(PHONY)),- due to target is PHONY,                    \
        $(if $(wildcard $@),                                                 \
            $(if $(strip $(any-prereq)),- due to: $(any-prereq),             \
                $(if $(arg-check),                                           \
                    $(if $(cmd_$@),- due to command line change,             \
                        $(if $(filter $@, $(targets)),                       \
                            - due to missing .cmd file,                      \
                            - due to $(notdir $@) not in $$(targets)         \
                         )                                                   \
                     )                                                       \
                 )                                                           \
             ),                                                              \
             - due to target missing                                         \
         )                                                                   \
     )

echo-why = $(call escsq, $(strip $(why)))
endif
