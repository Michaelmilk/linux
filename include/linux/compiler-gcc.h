#ifndef __LINUX_COMPILER_H
#error "Please don't include <linux/compiler-gcc.h> directly, include <linux/compiler.h> instead."
#endif

/*
 * Common definitions for all gcc versions go here.
 */
#define GCC_VERSION (__GNUC__ * 10000 \
		   + __GNUC_MINOR__ * 100 \
		   + __GNUC_PATCHLEVEL__)


/* Optimization barrier */
/* The "volatile" is due to gcc bugs */
/*
cpu越过内存屏障后，会刷新寄存器的状态
这条语句实际上不生成任何代码
barrier()宏只约束gcc编译器，不会约束运行时cpu的行为

__asm__内嵌汇编
__volatile__编译器不要对内嵌汇编代码进行优化
""指令为空
 输出部为空
 输入部为空
"memory"破坏部为内存
*/
#define barrier() __asm__ __volatile__("": : :"memory")

/*
 * This macro obfuscates arithmetic on a variable address so that gcc
 * shouldn't recognize the original var, and make assumptions about it.
 *
 * This is needed because the C standard makes it undefined to do
 * pointer arithmetic on "objects" outside their boundaries and the
 * gcc optimizers assume this is the case. In particular they
 * assume such arithmetic does not wrap.
 *
 * A miscompilation has been observed because of this on PPC.
 * To work around it we hide the relationship of the pointer and the object
 * using this macro.
 *
 * Versions of the ppc64 compiler before 4.1 had a bug where use of
 * RELOC_HIDE could trash r30. The bug can be worked around by changing
 * the inline assembly constraint from =g to =r, in this particular
 * case either is valid.
 */
/*
obfuscate: 使模糊
*/
#define RELOC_HIDE(ptr, off)					\
  ({ unsigned long __ptr;					\
    __asm__ ("" : "=r"(__ptr) : "0"(ptr));		\
    (typeof(ptr)) (__ptr + (off)); })

#ifdef __CHECKER__
#define __must_be_array(arr) 0
#else
/* &a[0] degrades to a pointer: a different type from an array */
#define __must_be_array(a) BUILD_BUG_ON_ZERO(__same_type((a), &(a)[0]))
#endif

/*
 * Force always-inline if the user requests it so via the .config,
 * or if gcc is too old:
 */
#if !defined(CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING) || \
    !defined(CONFIG_OPTIMIZE_INLINING) || (__GNUC__ < 4)

/*
编译时候，如果不指定优化选项，函数就不会被内联嵌入;
当指定了alway_inline这个关键字时候，就算编译时候不指定优化选项，函数也会被内联嵌入。
*/

# define inline		inline		__attribute__((always_inline)) notrace
# define __inline__	__inline__	__attribute__((always_inline)) notrace
# define __inline	__inline	__attribute__((always_inline)) notrace
#else
/* A lot of inline functions can cause havoc with function tracing */
# define inline		inline		notrace
# define __inline__	__inline__	notrace
# define __inline	__inline	notrace
#endif

/*
The deprecated attribute results in a warning 
if the type is used anywhere in the source file. 
This is useful when identifying types 
that are expected to be removed in a future version of a program. 
If possible, the warning also includes 
the location of the declaration of the deprecated type/variable/function, 
to enable users to easily find further information 
about why the type/variable/function is deprecated, 
or what they should do instead. 
已经被淘汰的类型/变量/函数，不建议使用
*/
#define __deprecated			__attribute__((deprecated))
/*
The packed attribute specifies that a variable or structure field 
should have the smallest possible alignment-
one byte for a variable, and one bit for a field, 
unless you specify a larger value with the aligned attribute.
Here is a structure in which the field x is packed, 
so that it immediately follows a:

          struct foo
          {
            char a;
            int x[2] __attribute__ ((packed));
          };
压缩结构存储
*/
#define __packed			__attribute__((packed))
/*
The weak attribute causes the declaration 
to be emitted(发散) as a weak symbol rather than a global. 
This is primarily useful in defining library functions 
which can be overridden in user code, 
though it can also be used with non-function declarations. 
Weak symbols are supported for ELF targets, 
and also for a.out targets when using the GNU assembler and linker.
弱属性函数，可被重写
*/
#define __weak				__attribute__((weak))

/*
 * it doesn't make sense on ARM (currently the only user of __naked) to trace
 * naked functions because then mcount is called without stack and frame pointer
 * being set up and there is no chance to restore the lr register to the value
 * before mcount was called.
 *
 * The asm() bodies of naked functions often depend on standard calling conventions,
 * therefore they must be noinline and noclone.  GCC 4.[56] currently fail to enforce
 * this, so we must do so ourselves.  See GCC PR44290.
 */
/*
Use this attribute on the ARM, AVR, C4x and IP2K ports 
to indicate that the specified function does not need 
prologue(序言)/epilogue(结语) sequences generated by the compiler. 
It is up to the programmer to provide these sequences. 
*/
#define __naked				__attribute__((naked)) noinline __noclone notrace

/*
指明函数无返回值。这样编译器会对函数代码更进一步优化。
同时也防止了编译器对无初始化的变量的警告。
*/
#define __noreturn			__attribute__((noreturn))

/*
 * From the GCC manual:
 *
 * Many functions have no effects except the return value and their
 * return value depends only on the parameters and/or global
 * variables.  Such a function can be subject to common subexpression
 * elimination and loop optimization just as an arithmetic operator
 * would be.
 * [...]
 */
/*
Many functions have no effects except the return value 
and their return value depends only on the parameters and/or global variables. 
Such a function can be subject to common subexpression elimination 
and loop optimization just as an arithmetic operator would be. 
These functions should be declared with the attribute pure.
pure属性用于函数的影响只有返回值，而且返回值只依赖于函数参数和/或全局变量
*/
#define __pure				__attribute__((pure))
/*
This attribute specifies a minimum alignment 
for the variable or structure field, measured in bytes.
按字节对齐
*/
#define __aligned(x)			__attribute__((aligned(x)))
#define __printf(a, b)			__attribute__((format(printf, a, b)))
#define __scanf(a, b)			__attribute__((format(scanf, a, b)))

/*
noinline指明函数属性禁止内联。
*/

#define  noinline			__attribute__((noinline))
#define __attribute_const__		__attribute__((__const__))
#define __maybe_unused			__attribute__((unused))
#define __always_unused			__attribute__((unused))

/*
1.__GNUC__用来表示gcc编译器的版本，gcc有gcc2,gcc3,gcc4。
gcc不同版本对c有着不同的扩充，而Linux内核又是使用了不同的gnu c的扩充。
所以不同的Linux内核当用不同的版本的gcc来编译。
Linux内核与gcc是平行发展的。
当Linux中的内核使用了新版本的gcc的c扩充后，
则该版本的Linux内核将只能用此版本或更新版本的gcc来编译。
2.在其它的编译器的头文件(compiler-gcc4.h,compiler-gcc3.h)中有这么一段注释： 
Never include this file directly. Include <linux/compiler.h> instead.
从上面的compiler.h文件中的源代码中看出原来编译器要先通过宏：
__GNUC__来确定gcc编译器的版本，再来决定选用包含哪个头文件。 
*/
#define __gcc_header(x) #x
#define _gcc_header(x) __gcc_header(linux/compiler-gcc##x.h)
#define gcc_header(x) _gcc_header(x)
#include gcc_header(__GNUC__)

#if !defined(__noclone)
#define __noclone	/* not needed */
#endif

/*
 * A trick to suppress uninitialized variable warning without generating any
 * code
 */
/*
一个小技巧，用来声明未初始化的变量而又避免产生警告
*/
#define uninitialized_var(x) x = x

#define __always_inline		inline __attribute__((always_inline))
